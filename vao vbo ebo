        GLuint VAO;                   // informations de sommet stockées dans un ou plusieurs VBO sont interprétées par le pipeline de rendu
        glGenVertexArrays(1, &VAO);   // génère un VAO en réservant un emplacement de mémoire pour stocker ses données.
        glBindVertexArray(VAO);       // lie le VAO pour spécifier la configuration des sommets stockés dans le VBO.
        glEnableVertexAttribArray(0); // active l'attribut de sommet pour l'index 0 
        float vertices[] = {
            0.5f,  0.5f, 0.0f,   // top right
            0.5f, -0.5f, 0.0f,   // bottom right
            -0.5f, -0.5f, 0.0f,  // bottom left
            -0.5f,  0.5f, 0.0f,  // top left
            0.0f,  1.0f, 0.0f,   
            -0.5f,  0.5f, 0.0f,
        };
        GLuint VBO; 
        glGenBuffers(1, &VBO);                                                         
       glBindBuffer(GL_ARRAY_BUFFER, VBO);                                            
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (void *)0);  
        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
        GLushort indices [] = {
            0, 1, 3,   // first triangle
           1, 2, 3,   // second triangle
           0, 4, 5,
       };
       GLuint EBO;
       glGenBuffers(1, &EBO);
       glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
       glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
        glBindVertexArray(VAO); // lie le VAO pour dessiner les sommets stockés.
        glUseProgram(shaderProgram->getShaderProgram());
        glDrawElements(GL_TRIANGLES, 9, GL_UNSIGNED_SHORT, 0);






	triangle tri;
    tri.p[0].x = -0.5f;
    tri.p[0].y = -0.5f;
    tri.p[0].z = 0.0f;
    tri.p[1].x = 0.5f;
    tri.p[1].y = -0.5f;
    tri.p[1].z = 0.0f;
    tri.p[2].x = 0.0f;
    tri.p[2].y = 0.5f;
    tri.p[2].z = 0.0f;
    unsigned int VBO;
    unsigned int VAO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);
    glBindVertexArray(VAO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(tri), &tri, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, 0); 
    glBindVertexArray(0); 
    glUseProgram(shaderProgram->getShaderProgram());
    glBindVertexArray(VAO);
    glDrawArrays(GL_TRIANGLES, 0, 3);








#include "../include/shape.hpp"

void shape::configureVBO(void)
{
    glGenBuffers(1, &this->VBO);
    glBindBuffer(GL_ARRAY_BUFFER, this->VBO);
    glBufferData(GL_ARRAY_BUFFER, this->Mesh.tris.size() * sizeof(triangle), this->Mesh.tris.data(), this->DrawType);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    glBindVertexArray(0);
}

void shape::draw(void)
{
    glBindVertexArray(this->VAO);
    glUseProgram(this->Shader->getShaderProgram());
    glBindBuffer(GL_ARRAY_BUFFER, this->VBO);
    glDrawArrays(GL_TRIANGLES, 0, this->Mesh.tris.size() * 3);
}

shape::shape(shader *shader, unsigned int DrawType,
	float x1, float y1, float z1,
	float x2, float y2, float z2,
	float x3, float y3, float z3)
{
	this->DrawType = DrawType;
	this->Shader = shader;

	triangle tri;
    tri.p[0].x = x1; tri.p[0].y = y1; tri.p[0].z = z1;
    tri.p[1].x = x2; tri.p[1].y = y2; tri.p[1].z = z2;
    tri.p[2].x = x3; tri.p[2].y = y3; tri.p[2].z = z3;
	this->Mesh.tris.push_back(tri);

	tri.p[0].x = x1 + 0.3; tri.p[0].y = y1 + 0.3; tri.p[0].z = z1 + 0.3;
    tri.p[1].x = x2 + 0.3; tri.p[1].y = y2 + 0.3; tri.p[1].z = z2 + 0.3;
    tri.p[2].x = x3 + 0.3; tri.p[2].y = y3 + 0.3; tri.p[2].z = z3 + 0.3;
	this->Mesh.tris.push_back(tri);


	glGenVertexArrays(1, &this->VAO);
	glBindVertexArray(this->VAO);
	this->configureVBO();
}

shape::~shape(void)
{ }










class Matrix4x4 {
public:
    float elements[16];

    Matrix4x4() {
        for (int i = 0; i < 16; i++) {
            elements[i] = 0;
        }
    }

    Matrix4x4(float values[16]) {
        for (int i = 0; i < 16; i++) {
            elements[i] = values[i];
        }
    }

    Matrix4x4 operator*(const Matrix4x4& other) const {
        Matrix4x4 result;
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                float sum = 0;
                for (int k = 0; k < 4; k++) {
                    sum += elements[i * 4 + k] * other.elements[k * 4 + j];
                }
                result.elements[i * 4 + j] = sum;
            }
        }
        return result;
    }

    static Matrix4x4 Identity() {
        Matrix4x4 result;
        result.elements[0] = 1;
        result.elements[5] = 1;
        result.elements[10] = 1;
        result.elements[15] = 1;
        return result;
    }

    static Matrix4x4 Perspective(float fov, float aspectRatio, float near, float far) {
        Matrix4x4 result;
        float rad = fov * (M_PI / 180.0f);
        float tanHalfFov = tanf(rad / 2);
        result.elements[0] = 1 / (aspectRatio * tanHalfFov);
        result.elements[5] = 1 / tanHalfFov;
        result.elements[10] = -(far + near) / (far - near);
        result.elements[11] = -1;
        result.elements[14] = -(2 * far * near) / (far - near);
        return result;
    }

    static Matrix4x4 Translation(float x, float y, float z) {
        Matrix4x4 result = Identity();
        result.elements[12] = x;
        result.elements[13] = y;
        result.elements[14] = z;
        return result;
    }

    static Matrix4x4 Scaling(float x, float y, float z) {
        Matrix4x4 result;
        result.elements[0] = x;
        result.elements[5] = y;
        result.elements[10] = z;
        result.elements[15] = 1;
        return result;
    }

    static Matrix4x4 RotationX(float angle) {
        Matrix4x4 result;
        float rad = angle * (M_PI / 180.0f);
        float cosVal = cosf(rad);
        float sinVal = sinf(rad);
        result.elements[0] = 1;
        result.elements[5] = cosVal;
        result.elements[6] = sinVal;
        result.elements[9] = -sinVal;
        result.elements[10] = cosVal;
        result.elements[15] = 1;
        return result;
    }

    static Matrix4x4 RotationY(float angle) {
        Matrix4x4 result;
        float rad = angle * (M_PI / 180.0f);
        float cosVal = cosf(rad);
        float sinVal = sinf(rad);
        result.elements[0] = cosVal;
        result.elements[2] = -sinVal;
        result.elements[5] = 1;
        result.elements[8] = sinVal;
        result.elements[10] = cosVal;
        result.elements[15] = 1;
        return result;
    }

    static Matrix4x4 RotationZ(float angle) {
        Matrix4x4 result;
        float rad = angle * (M_PI / 180.0f);
        float cosVal = cosf(rad);
        float sinVal = sinf(rad);
        result.elements[0] = cosVal;
        result.elements[1] = sinVal;
        result.elements[4] = -sinVal;
        result.elements[5] = cosVal;
        result.elements[10] = 1;
        result.elements[15] = 1;
        return result;
    }

    static Matrix4x4 Orthographic(float left, float right, float bottom, float top, float near, float far) {
        Matrix4x4 result;
        result.elements[0] = 2 / (right - left);
        result.elements[5] = 2 / (top - bottom);
        result.elements[10] = -2 / (far - near);
        result.elements[12] = -(right + left) / (right - left);
        result.elements[13] = -(top + bottom) / (top - bottom);
        result.elements[14] = -(far + near) / (far - near);
        result.elements[15] = 1;
        return result;
    }

};








    tri.sommet[0].x = +0.0f; tri.sommet[0].y = +0.3f; tri.sommet[0].z = 0.0f;
    tri.sommet[1].x = +0.0f; tri.sommet[1].y = +0.1f; tri.sommet[1].z = 0.0f;
    tri.sommet[2].x = +0.1f; tri.sommet[2].y = +0.0f; tri.sommet[2].z = 0.0f;
	Mesh.push_back(tri);

    tri.sommet[0].x = +0.0f; tri.sommet[0].y = +0.3f; tri.sommet[0].z = 0.0f;
    tri.sommet[1].x = -0.1f; tri.sommet[1].y = +0.0f; tri.sommet[1].z = 0.0f;
    tri.sommet[2].x = +0.1f; tri.sommet[2].y = +0.0f; tri.sommet[2].z = 0.0f;
	Mesh.push_back(tri);
